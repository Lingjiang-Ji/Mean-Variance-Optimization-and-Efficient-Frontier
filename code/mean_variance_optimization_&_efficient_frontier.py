# -*- coding: utf-8 -*-
"""Mean-Variance Optimization & Efficient Frontier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EWqikaXW0-Dg_c6kGj9bWoKGq1342nrT

# Mean Variance Optimization (MVO) and Efficient Frontier Overview

Meanâ€“Variance Optimization (MVO) is a classical framework for portfolio construction that balances **expected return and risk**, where risk is measured by the **variance (or volatility)** of portfolio returns.
By solving a sequence of constrained optimization problems, one can trace out the **efficient frontier**, which represents the set of portfolios that achieve the lowest possible risk for a given level of expected return.

In this framework, asset returns are summarized by their expected values and covariance structure. Portfolio weights are chosen to minimize total variance subject to budget and return constraints. Convex optimization techniques are used to ensure numerical stability and extensibility.

### Variables:
- $ r_t $: Vector of asset returns at time
ð‘¡
- $ Î¼ $: Vector of expected asset returns
- $ Î£ $: Covariance matrix of asset returns
- $ w $: Portfolio weight vector
- $ R $: Target portfolio return
- $ N $: Number of assets

### Steps to Compute the Efficient Frontier:
1. **Estimate return statistics**: Compute the expected returns ðœ‡ and covariance matrix Î£ from historical return data.
2. **Formulate the optimization problem**: For a given target return ð‘…, solve the minimum-variance portfolio problem:
   - Minimize portfolio variance  $w^\top \Sigma w$
   - Subject to budget and return constraints.
3. **Solve for optimal weights**: Use convex optimization to obtain the portfolio weights that satisfy the constraints.
4. **Sweep target returns**:
Repeat the optimization over a grid of target returns to generate the full efficient frontier.

### Result:
The collection of solutions forms the efficient frontier, which characterizes the optimal trade-off between risk and expected return.

Each point on the frontier corresponds to a portfolio allocation that is meanâ€“variance efficient under the specified constraints.

# Implementation and an Example

Consider a simple portfolio optimization setup with **N = 4** assets.
The dataset spans the period **1960â€“2002** and consists of total returns from the following asset classes:

  - S&P 500 equity index

  - Long-term bonds

  - Money market account

  - NASDAQ stocks

**Expected portfolio returns ð‘…** are evaluated over a range from **6.5%** to **10.5%**, with increments of **0.5%**.

Based on the return data, the expected return vector Î¼ and the covariance matrix Î£ are estimated and used as inputs to a meanâ€“variance optimization framework. For each target return level ð‘…, a minimum-variance portfolio is computed under standard budget and long-only constraints.

The resulting portfolio weights, expected returns, and volatilities are then collected to construct the efficient frontier.
"""

# Commented out IPython magic to ensure Python compatibility.
!pip install cvxpy
import cvxpy as cp
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline

data = pd.read_csv('mvo-data.csv', sep = ' ', header=None).dropna(axis=1)
data.index = np.arange(1960, 2004)
data.columns = ['stocks_SP500', 'bonds', 'market_account', 'stocks_Nasdaq']

data.head()

"""## Step 1
Prepare the mean vector, covariance matrix and expected returns
"""

# rate of return matrix
r = data.pct_change(1).dropna(axis=0)
r.head()

# arithmetic mean
arith_mean = np.mean(r, axis=0)
arith_mean

# geometric mean
geo_mean = np.exp(np.log1p(r).mean(axis=0)) - 1 # note here .lop1p already add 1 to r
geo_mean

# centered matrix (r_it - mean(r_1))
r_centered = r - arith_mean # here msut use arithmetic mean

# covariance matrix V
V = r_centered.T.dot(r_centered) / r.shape[0]
V

# define the expected returns
Rs = np.arange(0.065, 0.11, 0.005)

"""## Step 2
Use the package CVXPY is used to construct the MVO solver. Using the solver to get the weights for each optimal portfolio with different expected returns, then calculate the standard deviation and true return from those portfolios.
"""

# create the function to solve this problem
def MVO_solver(n, R, mu, Sigma):
  """
    Solve a meanâ€“variance portfolio optimization problem with a minimum
    target return constraint.

    The function computes the minimum-variance portfolio subject to:
    - a full-investment (budget) constraint,
    - a minimum expected return requirement,
    - and long-only weights.

    Parameters
    ----------
    n : int
        Number of assets in the portfolio.
    R : float
        Minimum target portfolio return.
    mu : array_like, shape (n,) or (1, n)
        Expected returns of the assets.
    Sigma : array_like, shape (n, n)
        Covariance matrix of asset returns.

    Returns
    -------
    numpy.ndarray, shape (n,)
        Optimal portfolio weights that minimize variance while satisfying
        the constraints.

    Notes
    -----
    This problem is formulated as a convex quadratic program and is solved
    using CVXPY. The default solver is selected automatically by CVXPY.
  """
  mu = np.asarray(mu).reshape(-1)
  Sigma = np.asarray(Sigma)

  x = cp.Variable(n) # x is the weight vector we want to get

  objective = cp.Minimize(cp.quad_form(x, Sigma)) # given expected return, minimize standard deviation

  constraints = [
      cp.sum(x) == 1,
      mu @ x >= R,
      x >= 0 # here we don't allow short
  ]

  prob = cp.Problem(objective, constraints)
  prob.solve()

  return x.value

# pass the result to weights matrix
weights = pd.DataFrame(
    [MVO_solver(r.shape[1], R, arith_mean, V) for R in Rs],
    index=Rs,
    columns=data.columns)
weights.index.name = 'target_returns'

pd.set_option('display.float_format','{:.5f}'.format)
weights

# store the standard deviation of each optimal portfolio and the corresponding expected return
effft = pd.DataFrame(
    index = Rs,
    columns = ['Standard Deviation', 'Expected Return'])
effft.index.name = 'target_returns'

effft['Standard Deviation'] = [np.sqrt(w @ V @ w) for w in weights.values]
effft['Expected Return'] = [arith_mean @ w for w in weights.values]

effft

"""## Step 3
The standard deviation (risk) and expected return sets for the optimal weighted portfolios are obtained, we can use them to plot the efficient frontier.
"""

plt.figure()
plt.plot(
    effft['Standard Deviation'],
    effft['Expected Return'],
    marker = 'o',
)
plt.xlabel('Standard Deviation')
plt.ylabel('Expected Return')
plt.title('Efficient Frontier')
plt.show()